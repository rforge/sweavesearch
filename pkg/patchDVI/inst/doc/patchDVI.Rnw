\documentclass[12pt]{article}
\usepackage{Sweave}
\usepackage{natbib}
\usepackage{hyperref}
\bibliographystyle{plain}

\SweaveOpts{concordance=TRUE}

\newcommand{\patchDVI}{\patchDVIn\ }
\newcommand{\patchDVIn}{\textbf{patchDVI}}

%\VignetteIndexEntry{The patchDVI package}

\title{The \patchDVI package}
\author{Duncan Murdoch}

\begin{document}

\maketitle

\abstract{
The \patchDVI package works with Sweave \citep{Leisch02}  and
document previewers to facilitate editing:  it modifies the links
that \LaTeX\ puts into the output so that they refer to the original
source.  It also includes a few project management functions to 
make large multi-file Sweave documents easier to handle.}

\section{Introduction}

Most implementations of \LaTeX\ allow source references to be emitted, so
that previewers of the \texttt{.dvi} or \texttt{.pdf} output file can
link back to the original source line.  This has been a feature of the
\texttt{yap} previewer for \texttt{.dvi} files in MikTeX \citep{Schenk10}
for many
years.  Support for source references has appeared more recently
for \texttt{.pdf}
output in \texttt{pdfsync} and is currently available in Synctex \citep{Laurens08}.

Unfortunately for Sweave users, these links point to the \texttt{.tex}
source that was processed, which is not the true source code in the
Sweave \texttt{.Rnw} or \texttt{.Snw} or other input file.  (I will
refer to all of these as \texttt{.Rnw} files.)
Clicking on ``go to source''
in a previewer will jump to the \texttt{.tex} file; changes made there
will be lost the next time the Sweave input is processed.

I wrote the \patchDVI package to address this problem.  It works as
follows.  If the Sweave file is processed with the option
\texttt{concordance=TRUE}, Sweave will output a record of the
concordance between the lines in the input file and the output file.
When the file is processed by \LaTeX, this information is embedded in
the output.  (Details of the embedding are described in sections \ref{sec:concordance}
to \ref{sec:synctex} below.)  After
producing the \texttt{.dvi} or \texttt{.pdf} file, a \patchDVI
function is run to read the concordance information and to patch the
source reference information produced by \LaTeX.  Once this has been
done, previewers will see references to the original Sweave source
rather than the \LaTeX\ intermediate file.

Besides the technical details mentioned above, 
this paper describes the history of \patchDVI in the next section and
in section \ref{sec:make} some
project management functions.  It concludes with a short discussion.

\section{\patchDVI History}\label{sec:history}

Initially  \patchDVI only worked for \texttt{.dvi} files (hence the name).
It required changes to the Sweave function in R, which 
first appeared around the release of R version
2.5.0. with incompatible changes in R version 2.8.0 when \texttt{.pdf}
support was added to \patchDVI.

Using \patchDVI requires a pre-processing step (Sweave), \LaTeX\ 
processing, and a post-processing step (patching).  This is usually
followed by a preview of the resulting output file.  It quickly became
apparent that it was convenient to package these steps into a
single R function, so the user only needed to make a single call.  But
the details of \LaTeX\  processing vary from platform to platform, so I
wrote functions \texttt{SweaveMiktex} and \texttt{SweavePDFMiktex}
specific to the MikTex platform, with the intention of adding
others as I used them or users told me what needed adding.  This never happened,
but in the meantime, Brian Ripley made the \texttt{tools::texi2dvi} function
in R much more flexible, and in the recent release of version 1.7 of
\patchDVI I have included a modified version of it with the hope that
\patchDVI will now be more nearly platform neutral.

The 1.7 release was motivated by an attempt to support TeXWorks \citep{Kew10}, a
cross-platform \LaTeX\ targetted editor.  TeXWorks is still in its early
days (I was working with version 0.2 on Windows), and it did not have
enough flexibility to handle large Sweave projects, where for example, each
chapter of a book requires separate Sweave processing, but \LaTeX\ processes
only a main wrapper file.  This prompted me to include more \texttt{make}-style
capabilities into \patchDVIn.  It is now possible to specify a list of
Sweave input files to process (optionally only if they have changed since the
last processing) and the main wrapper file, all within Sweave chunks
in a single file, using the \texttt{SweaveAll} function.

\section{Sweave Concordances}\label{sec:concordance}

Sweave processes the code chunks in the \texttt{.Rnw} file, replacing each
with the requested output from the command.  This means that the output \texttt{.tex}
file alternates between copied \LaTeX\ source and newly produced blocks of 
output.  Each line in the \texttt{.tex} file can thus be mapped to 
one or more lines of input, and that is what the concordance does.

The concordance records are text records in the following format.  There are
four parts, separated by colons:
\begin{enumerate}
\item The label \texttt{concordance} to indicate the type of record.
\item The output \texttt{.tex} filename.
\item The input \texttt{.Rnw} filename.
\item The input line numbers corresponding to each output line.
\end{enumerate}
The third component is compressed using a simple encoding:  The first
number is the first line number; the remainder of line numbers are a
run-length encoding of the differences.  Thus if the input file is as
shown in Table \ref{tab:input}, 
\begin{table}
\caption{Input file for simple example.\label{tab:input}}
\begin{center}
\begin{tabular}{ll}
\hline
Line number & Input text \\
\hline
1 & \verb!\SweaveOpts{concordance=TRUE}!  \\
2 & This is text  \\
3 & \verb!<<>>=!  \\ 
4 & \verb!123! \\
5 &  \verb!@! \\
6 & This is more text  \\
\hline
\end{tabular}
\end{center}
\end{table}
the output file would be as
shown in Table \ref{tab:output}, with the concordance as shown there in the second column.
\begin{table}
\caption{Output file for simple example.\label{tab:output}}
\begin{center}
\begin{tabular}{lll}
\hline
Output line & Input line &  Output text \\
\hline
1 & 1 & \verb!\input{sample-concordance}! \\
2 & 2 & This is text. \\
3 & 4 & \verb!\begin{Schunk}! \\
4 & 4 & \verb!\begin{Sinput}! \\
5 & 4 & \verb!> 123! \\
6 & 4 & \verb!\end{Sinput}! \\
7 & 4 & \verb!\begin{Soutput}! \\
8 & 4 & \verb![1] 123! \\
9 & 4 & \verb!\end{Soutput}! \\
10 & 4 & \verb!\end{Schunk}! \\
11 & 6 & This is more text \\
\hline
\end{tabular}
\end{center}
\end{table}
This concordance would be recorded in the file \texttt{sample-concordance.tex}
as
\begin{verbatim}
\Sconcordance{concordance:sample.tex:sample.Rnw:%
1 1 1 1 2 7 0 1 2}
\end{verbatim}
The numeric part of this file may be interpreted as shown in Table \ref{tab:concordance}.
\begin{table}
\caption{Encoding of numeric part of concordance record.\label{tab:concordance}}
\begin{center}
\begin{tabular}{lll}
\hline
Values & Interpretation & Expansion \\
\hline
\texttt{1} & line 1  & 1 \\
\texttt{1 1} & 1 increase of 1 & 2 \\
\texttt{1 2} & 1 increase of 2 & 4 \\
\texttt{7 0} & 7 increases of 0 & 4 4 4 4 4 4 4 \\
\texttt{1 2} & 1 increase of 2 & 6 \\
\hline
\end{tabular}
\end{center}
\end{table}

\section{Patching \texttt{.dvi} Files}\label{sec:dvi}

The \verb!\Sconcordance! macro expands to a \verb!\special! macro when
producing a \texttt{.dvi} file.  This is included verbatim in the \texttt{.dvi}
file. The ``concordance:'' prefix identifies it as a \patchDVI concordance.
The \texttt{patchDVI} function scans the whole file until it finds
this sort of record.  (There may be more than one, if multiple files make up
the document.)  Source references are also recorded by \LaTeX\ in \verb!\special! records; 
their prefix is ``src:''.  The \texttt{patchDVI} function reads
each ``src:'' special and if it refers to a file in a ``concordance:'' special,
makes the substitution.  At the end, it rewrites the whole \texttt{.dvi} file.


\section{Patching \texttt{.synctex} Files}\label{sec:synctex}

For \texttt{.pdf} files, the \verb!\Sconcordance! macro expands to a
\verb!\pdfobj! macro containing the concordance, which eventually is
embedded in the \texttt{.pdf} file.  However, the Synctex scheme of
source references does not write them to the \texttt{.pdf} file
directly.  Instead, they are written to a separate file with extension
\texttt{.synctex}, or a compressed version of that file, with
extension \texttt{.synctex.gz}.  The \texttt{patchSynctex} function
reads the concordances from the \texttt{.pdf} file and the source
references from the Synctex file.  It rewrites only
the Synctex file when it makes its changes.

\section{Project Management Function \texttt{SweaveAll}}\label{sec:make}

As mentioned above, there are a number of steps involved in running \patchDVI
with a complex Sweave project:
\begin{enumerate}
\item Run Sweave on each input file.
\item Run \LaTeX\ on the main wrapper file.
\item Run the appropriate \patchDVI function on the output file.
\item Preview or print the result.
\end{enumerate}
Moreover, step 1 needs to be repeated once for each Sweave file, but only
if the content has changed since the last run, while the other steps need only
be done once.

To manage this complication, the \patchDVI package now includes a simple
project management function, \texttt{SweaveAll}.  This function runs Sweave
on multiple files and determines the name of the main wrapper file.  It is 
used internally by the functions described in Section \ref{sec:complete}
below, but can also be called directly by the user.

Here is how it works.  \texttt{SweaveAll} takes a vector
of filenames as input, and runs Sweave on each.  After each run, it examines the
global environment for three variables:  \texttt{.PostSweaveHook},
\texttt{.SweaveFiles} and \texttt{.TexRoot}.

A code chunk in a \texttt{Rnw} file may produce a function (or the name of
a function; \texttt{match.fun} is used to look it up) named \texttt{.PostSweaveHook}.
If present, this should be a function taking a single argument.  
Immediately after running \texttt{Sweave}, 
\texttt{SweaveAll} will call this function, passing the name of the 
\texttt{.tex} output file as the only argument.  The hook can do any
required postprocessing, for example, it could remove local
pathnames from output strings.

The optional parameter \texttt{PostSweaveHook} to the \texttt{SweaveAll} function
can provide a default hook function.  Hooks specified via \texttt{.PostSweaveHook}
take precedence in any given input file.

\texttt{SweaveAll} will also check for a character vector
named \texttt{.SweaveFiles}.  It should contain the names of  \texttt{.Rnw} 
files in the project.  If no corresponding \texttt{.tex} file exists, or the
\texttt{.Rnw} file is newer, they will be run through Sweave.  They may in
turn name additional \texttt{.Rnw} files to process; each file is processed
only once, even if it is named several times.

There is an optional parameter named \texttt{make} to the \texttt{SweaveAll} function.
If \texttt{make=1} (the default), things proceed as described above.  If \texttt{make=0},
the \texttt{.SweaveFiles} variable is ignored, and only the explicitly named
files in the call to \texttt{SweaveAll} are processed.  If \texttt{make=2}, then
all files are processed, whether they are newer than their \texttt{.tex} 
file or not.

A \texttt{.Rnw} file may also set the value of \texttt{.TexRoot} to the name of
a \texttt{.tex} file.  If it does, then that is the file that should be passed
to \LaTeX\ for processing.  If none is given, then the first file in the call
to \texttt{SweaveAll} will be assumed to be the root file.  (If multiple
different \texttt{.TexRoot} variables are specified by different \texttt{.Rnw}
files, one of them will be used, but it is hard to predict which:  so don't do
that.)  Whichever file is determined to be the root file is the name returned
by the \texttt{SweaveAll} call.

\texttt{SweaveAll} is called by all of the functions described in subsection
\ref{sec:complete} below to do step 1 of the \patchDVI steps.

The workflow this is designed for is as follows.  Each \texttt{.Rnw}
chapter (named for example ``chapter.Rnw'') 
in a large project should specify the \texttt{.TexRoot}, e.g. using the
code chunk
\begin{verbatim}
 <<echo=FALSE>>=
 .TexRoot <- "wrapper.tex"
 @
\end{verbatim}
Similarly, the wrapper file (named for example
``wrapper.Rnw'') should be a \texttt{.Rnw} file that sets
\texttt{.SweaveFiles} to the complete list of files in the project.
Then one can build an initial copy of the entire document by calling
\texttt{SweavePDF} or \texttt{SweaveDVI} 
(or the MikTeX versions) with argument \texttt{"wrapper.Rnw"}.
Later, while one is working on ``chapter.Rnw'', one can call
one of those functions
with argument \texttt{"chapter.Rnw"} 
and the chapter will be processed through
the full sequence, without running Sweave on the other chapters.

More complicated schemes are possible.  For example:
\begin{itemize}
\item Each chapter can have subsections in separate
files; then the chapter would name the subsections, but the main wrapper would only
need to name the chapters.  
\item If one wants to ``make'' the full project every time,
then include \texttt{"wrapper.Rnw"} in \texttt{.SweaveFiles} in each chapter.
\end{itemize}

\subsection{The Complete Process}\label{sec:complete}

The \patchDVI package contains four functions designed to run all
four of the steps listed at the start of this section.  The functions
\texttt{SweaveDVI} and \texttt{SweaveMiktex} produce \texttt{.dvi} output
in the general case and for MikTeX respectively; \texttt{SweavePDF} and
\texttt{SweavePDFMiktex} do the same for \texttt{.pdf} output.

For example, the text editor that I use allows me to call external
functions with arguments depending on the name of the current file and
the line number within it.  I have it call a Windows batch file 
with the line set as argument \verb!%1! and the filename
set as argument \verb!%2!; the batch
file invokes R using the command line
\begin{verbatim}
echo patchDVI::SweaveMiktex('%2', 
    preview='yap -1 -s"%1%2" "\x25s"') 
    | Rterm --slave
\end{verbatim}
(all on one long line).  This passes the current file to \texttt{SweaveMiktex},
and sets the preview command to use the \texttt{yap} options \texttt{-1} to 
update the current view (rather than opening a new window), and to jump to the
line corresponding to the editor line.  The code \verb!"\x25s"! is simply
\verb!"%s"! encoded without an explicit percent sign, which would be 
misinterpreted by the Windows command processor.  When \patchDVI calls
the previewer, the main \texttt{.dvi} filename will be substituted for
\verb!%s!.


\section{Conclusion}\label{sec:conclusion}

As described in this paper, the \patchDVI package is a convenient way
to work with Sweave in a modern setting, allowing fast switching from
source input to preview.  It also offers some features to make the
management of larger projects easier.  

Other possibilities may exist to make use of the code in this package.  In
order to read and patch \texttt{.dvi}, \texttt{.pdf} and \texttt{.synctex}
files, \patchDVI includes code to work with each of those formats.  Users may
find imaginative uses for this capability, which I've tried to leave 
in general form.  The low-level \texttt{.dvi} editing is done by C functions
called from R, while the PDF related work is done in pure R code.  

\bibliography{patchDVI}

\end{document}
